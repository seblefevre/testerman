# __METADATA__BEGIN__
# <?xml version="1.0" encoding="utf-8" ?>
# <metadata version="1.0">
# <description>Testerman auto test to pass before any release.</description>
# <prerequisites></prerequisites>
# <parameters>
# <parameter name="PX_UNICODE_STRING" default="ça marche" type="string"><![CDATA[Unicode session variable test. Do not change its value.]]></parameter>
# </parameters>
# </metadata>
# __METADATA__END__
##
# Testerman core feature (TTCN-3 oriented) auto tests.
#
##
 
##
# templates (messages) definitions
##

# None shared between testcases.

##
# Test case definitions
##

class TC_TIMER(TestCase):
	"""
	Basic Timer Management.
	Run two timers, etc.
	"""
	def body(self):
		log("Testerman autotest: timer basic management")
		
		# Let's define a timer
		t = Timer(1.5)
		
		# Start and stop.
		t.start()
		t.stop()
		
		# Restart, timeout
		t.start()
		alt([
			[ t.TIMEOUT,
				lambda: log("timeout correctly received"),
				lambda: setverdict("pass"),
			]
		])
		
		# Multiple timers.
		t1 = Timer(3.0)
		t2 = Timer(1.0)
		t1.start()
		t2.start()
		alt([
			[ t2.TIMEOUT,
				lambda: log("Shortest timeout correctly received"),
				lambda: t1.stop(),
				lambda: setverdict("pass"),
			],
			[ t1.TIMEOUT,
				lambda: log("Sorry, the longuest timeout was received first"),
				lambda: setverdict("fail"),
			]
		])
		
		# "Sleep simulator": this is the TTCN-3 way to create a sleep(2000ms).
		s = Timer(1.0)
		s.start()
		s.timeout()
		
		# running() test
		
		log("Checking running()...")
		if s.running():
			log("Stopped timer seen as running. Test failed.")
			setverdict("fail")
		s.start(1)
		if not s.running():
			log("Started timer not seen as running. Test failed.")
			setverdict("fail")
		s.stop()
		
		log("Checking read()...")
		# Read timer expected accuracy: 50ms
		delta = 0.05
		t1.start(5.0)
		t2.start(1.0)
		t2.timeout()
		# Normally, t1 started 1 second ago
		d = t1.read()
		if abs(1.0 - d) > delta:
			log("Incorrect read timer: got %f, expected 1s" % d)
			setverdict("fail")
		log("Read timer accuracy: %fs" % abs(1.0 - d))
			
		setverdict("pass")
		log("End of testcase reached.")

class TC_SIMPLE_CONNECTION(TestCase):
	"""
	This sample demonstrates simple port communications.
	"""
	def body(self):
		log("Testerman autotest: implicit MTC, simple port communications")
		self.setDescription("A description. Overriding the default one.")
		
		# Let's define a PTC
		ptc01 = self.create()
		
		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		connect(p01, p02)
		
		# Let's send a message through port 01 and wait for it on port02
		p01.send("This is a great stuff")
		p02.receive()
		
		p02.send("This is really nice")
		alt([
			[ p01.RECEIVE("This is really nice"),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE("Something else"),
				lambda: setverdict("inconc")
			],
			[ p01.RECEIVE(),
				lambda: setverdict("fail")
			],
		])

		# Order does matter in case of multiple matched events
		p02.send(11)
		alt([
			[ p01.RECEIVE(greater_than(10)),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE(greater_than(5)),
				lambda: setverdict("fail")
			],
		])
		
		# Port disconnection
		disconnect(p01, p02)
		p01.send("This is a great stuff")
		t = Timer(1.0)
		t.start()
		alt([
			[ p02.RECEIVE(),
				lambda: log("Unexpected message received on a disconnected port"),
				lambda: setverdict("fail"),
				lambda: t.stop()
			],
			[ t.TIMEOUT,
				lambda: log("OK, nothing received on a disconnected port"),
				lambda: setverdict("pass"),
			],
		])
		
		# Loopback connection
		connect(p01, p01)
		p01.send("Loopback connection")
		p01.receive("Loopback connection")
		
		log("End of testcase reached.")

class TC_SIMPLE_1TON(TestCase):
	def body(self):
		log("Testerman autotest: implicit MTC, multiple ptc, one to N connections, no tsi, no ptc behavior, timeout objects")
		
		# Let's create some PTCs
		ptc01 = self.create()
		ptc02 = self.create()
		
		# Let's connect some ports: p01 connected to p02 and p03
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		p03 = ptc02['port03']
		connect(p01, p02)
		connect(p01, p03)
		
		# When sending something through p03, only p01 receives it.
		p03.send("message to p01")
		alt([
			[ p02.RECEIVE(),
				lambda: log("received an unexpected message on p02"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
			[ p01.RECEIVE("message to p01"),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE(),
				lambda: log("received an incorrect message on p01"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
		])
		
		# When sending something through p01, both p02 and p03 receives it.

		# Long version, with precise case to diagnose the problem		
		p01.send("message to p02+p03")
		timer = Timer(5.0)
		timer.start()
		alt([
			[ p02.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p02.RECEIVE(),
						lambda: log("Multiple messages received on p02"),
						lambda: setverdict("fail"),
					],
					[ p03.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p03"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p03.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p02"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()

		# Short version, no timeout watchdog. It worked once, so it should work once more.
		p01.send("message to p02+p03")
		p02.receive("message to p02+p03")
		p03.receive("message to p02+p03")
		
		log("End of testcase reached.")

class TC_SIMPLE_1TON_SUBSET(TestCase):
	def body(self):
		log("Testerman autotest: implicit MTC, multiple ptc, one to N connections")
		
		# Let's create some PTCs
		ptc01 = self.create(name = "PTC01")
		ptc02 = self.create(name = "PTC02")
		ptc03 = self.create(name = "PTC03")
		
		# Let's connect some ports: p01 connected to p02, p03, p04
		p01 = self.mtc['port']
		p02 = ptc01['port']
		p03 = ptc02['port']
		p04 = ptc03['port']
		connect(p01, p02)
		connect(p01, p03)
		connect(p01, p04)
	
		# Sending to a single component: p01 to p03 only
		p01.send("message to p03", ptc02)
		timer = Timer(1.0)
		timer.start()
		alt([
			[ p02.RECEIVE(),
				lambda: log("Received message on p02, failed"),
				lambda: setverdict("fail"),
			],
			[ p03.RECEIVE("message to p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE(),
						lambda: log("Received message on p02, failed"),
						lambda: setverdict("fail"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on other ports - OK"),
					],
				])
			],
			[ p04.RECEIVE(),
				lambda: log("Received message on p04, failed"),
				lambda: setverdict("fail"),
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()

		# When sending something through p01 to ptc01, ptc02, so p04 (on ptc03) does not receive it

		p01.send("message to p02+p03", [ ptc01, ptc02 ])
		timer = Timer(1.0)
		timer.start()
		alt([
			[ p02.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p02.RECEIVE(),
						lambda: log("Multiple messages received on p02"),
						lambda: setverdict("fail"),
					],
					[ p03.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p03"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p03.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p02"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p04.RECEIVE(),
				lambda: log("Received message on p04, failed"),
				lambda: setverdict("fail"),
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()
		
		log("End of testcase reached.")

class BEHAVIOUR_SIMPLE_PTC(Behaviour):
	def body(self):
		"""
		This is a sample behaviour for TC_SIMPLE_PTC
		"""
		# Get an aliases referenced to the ports that are assumed
		# to be connected
		
		# alternative: p02 = self.ptc['port02']
		p02 = self['port02']
		
		# The usual watchdog
		t = Timer(2.0, name = "watchdog")
		t.start()
		alt([
			[ p02.RECEIVE("ping"),
				lambda: p02.send("pong"),
			],
			[ t.TIMEOUT,
				lambda: log("timeout while waiting for a ping"),
				lambda: setverdict("fail")
			]
		])
		t.stop()

		log("This log was created from a parallel test component")
		
		# Let's create an articifial delay so that the ptc.done() must wait a little.
		# Note: timers are not interruptible with a ptc.stop() or kill().
		t = Timer(2.0)
		t.start()
		t.timeout()
		
		# PTC verdicts are taken into account to determine the final testcase verdict
		# Will only be set to pass if not already failed due to the watchdog timeout above
		setverdict("pass")

class TC_SIMPLE_PTC(TestCase):
	def body(self):
		log("Testerman autotest: PTC (ping replier)")
		
		# Let's define a PTC
		ptc01 = self.create(name = "Simple PTC")
		
		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		connect(p01, p02)
		
		# Let's start ptc01 with a simple sample behavior.
		# Note: it is dangerous to change the test configuration (i.e. the port connections) after starting PTCs.
		ptc01.start(BEHAVIOUR_SIMPLE_PTC())
		
		# Let's send a message through port 01. The Behavior_Sample3 is expected to echo the message, adding a final * to it.
		p01.send("ping")
		
		p01.receive("pong")

		# Let's wait for ptc01 to finish
		ptc01.done()

		# In this testcase, only the PTC behavior verdict can set the testcase verdict to pass. This is what we want to test.
		log("End of testcase reached.")


class BEHAVIOUR_ALIVE_NONALIVE(Behaviour):
	"""
	You may also add a description here, but it won't be reflected into execution
	logs (for now).
	Still convenient for self documentation.
	"""
	def body(self):
		p = self['port']

		alt([
			[ p.RECEIVE("This is a message"), # this is a comment
				lambda: stop() # stop the behavior/PTC (no need to put it here, just to show it off)
			],
			[ p.RECEIVE("This is an almost missed message"),
				lambda: setverdict("pass"), # ok, this is the missed message that can be received only on alive components.
			]
		])

		
class TC_ALIVE_AND_NONALIVE(TestCase):
	def body(self):
		log("Testerman autotest: alive and non-alive component")
		
		# Let's define a non-alive PTC (the default create() mechanism)
		# The PTC will be killed automatically once start(behavior()) is over on it.
		ptcNA = self.create(name = "ptc01, non alive")
		
		# Now, let's create an alive component
		ptcA = self.create(alive = True)

		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		pA = ptcA['port']
		pNA = ptcNA['port']
		connect(p01, pA)
		connect(p02, pNA)
		
		# Let's start ptc01 with a simple sample behavior.
		# Note: it is dangerous to change the test configuration (i.e. the port connections) after starting PTCs.
		ptcNA.start(BEHAVIOUR_ALIVE_NONALIVE())
		p02.send("This is a message")
		ptcNA.done()
		# automatically killed
		if ptcNA.alive():
			setverdict("fail")
			log("non alive component not automatically killed")
			stop()
		else:
			log("ptcNA was killed")
		

		# on alive component, when stopped (explicitly or on done()) and then restarted with the same or a new behavior,
		# the port queues are unchanged. As a consequence, when restarting your new behavior, you may read
		# events that you 'missed' during the component inactivity.
		ptcA.start(BEHAVIOUR_ALIVE_NONALIVE())
		p01.send("This is a message")
		ptcA.done()
		if not ptcA.alive():
			setverdict("fail")
			log("alive component automatically killed")
			stop()
		
		p01.send("This is an almost missed message")
		
		ptcA.start(BEHAVIOUR_ALIVE_NONALIVE())
		# ptcA will receive the missed message
		ptcA.done()

		# The verdict is defined by the synthesis of all PTC verdicts + current testcase verdict (set to 'none' by default)		
		log("End of testcase reached.")

		# remaining PTCs are automatically stop()ed and kill()ed when the TestCase if finished.

class TC_VALUE_EXTRACTION(TestCase):
	def body(self):
		log("Testerman autotest: template matching and value extraction")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		# The template match is performed with the new value() complete message extractor function.
		# This avoids to incorporate in templates extractors, which are context-dependent.
		p01.send( { 'field1': 'value1', 'field2': 'value2' } )
		alt([
			[ p02.RECEIVE({ 'field2': any() }, 'message'),
				lambda: log("Received message: " + str(value('message'))),
				lambda: log("Received message field: " + value('message')['field1']),
				lambda: setverdict("pass"),
			],
		])

		log("End of testcase reached.")

class TC_CODEC(TestCase):
	def body(self):
		log("Testerman autotest: simple codec management in templates")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		template = { 'string': 'a string', 'unicode': u"comment ca va ?", 'list': [1, 2, 3], 'tuple': ('choiceName', 'value') }
		
		template_codec = with_('pickle', template)

		# TODO: support for a codec anywhere in the struct, on only at start
		template = with_('pickle', { 'base64': with_('base64', 'hello'), 'no-encoding': 'yo' })

		p01.send(template)
		alt([
			[ p02.RECEIVE(template, 'message'),
				lambda: log("Received message: " + str(value('message'))),
				lambda: setverdict("pass"),
			],
			[ p02.RECEIVE(),
				lambda: log("Something else received."),
				lambda: setverdict("fail"),
			],
		])

		log("End of testcase reached.")

class TC_TEMPLATE_MATCH_GENERAL(TestCase):
	def body(self):
		log("Testerman autotest: template matching, general mechanisms")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		def assert_match(message, template):
			res = StateManager(False)
			t = Timer(1.0)
			t.start()
			p01.send(message)
			alt([
				[ p02.RECEIVE(template),
					lambda: res.set(True)
				],
				[ p02.RECEIVE(),
				],
				[ t.TIMEOUT,
				],
			])
			t.stop()
			return res.get()
			
		try:
			# Unit testing: simple types
			if not assert_match('string', None): raise Exception('(all match)')
			if not assert_match('string', 'string'): raise Exception('string')
			if not assert_match(u'unicode', u'unicode'): raise Exception('unicode')
			if not assert_match(1234, 1234): raise Exception('integer')
			if not assert_match(1234.0, 1234.0): raise Exception('float')
			if not assert_match(True, True): raise Exception('bool')
			if not assert_match(False, False): raise Exception('bool')
			if not assert_match(('choiceName', 'value'), ('choiceName', 'value')): raise Exception('couple')
			if not assert_match([ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ]): raise Exception('list/0')
			if not assert_match([ 1, 2, 3, 4 ], superset()): raise Exception('list/0')
			if not assert_match([ 1, 2, 3, 4 ], superset(2)): raise Exception('list/1')
			if not assert_match([ 1, 2, 3, 4 ], superset(1, 2)): raise Exception('list/2')
			if not assert_match([ 1, 2, 3, 4 ], superset(1, 2, 3, 4)): raise Exception('list/3')
			if not assert_match({ 'key1': 'value1' }, { }): raise Exception('dict/0')
			if not assert_match({ 'key1': 'value1' }, { 'key1': 'value1' }): raise Exception('dict/1')
			if not assert_match({ 'key0': 'value0', 'key1': 'value1' }, { 'key1': 'value1' }): raise Exception('dict/2')

			# Nested types
			message = { 'string': 'a string', 'unicode': u"comment ca va ?", 'list': [1, 2, 3], 'tuple': ('choiceName', 'value') }
			if not assert_match(message, message): raise Exception('recursive/0')
			if not assert_match(message, { 'list': superset(2) }): raise Exception('recursive/1')
			if not assert_match(message, { 'tuple': ('choiceName', 'value') }): raise Exception('recursive/2')
			
			message = ('choiceName', [ { 'key': [ ('choiceName2', { 'key2': 2.0 } ) ] }, { 'key4': [ ('choiceName2', { 'key2': 1.0 } ), ('choiceName3', { 'key2': 1.0 } ), ('choiceName4', { 'key2': 3.0 } ) ] } ])
			if not assert_match(message, message): raise Exception('recursive/3')
			if not assert_match(message, ('choiceName', superset({ 'key4': superset(('choiceName3', { 'key2': 1.0 }))}))): raise Exception('recursive/4')
	
			setverdict('pass')
		except Exception, e:
			log("Unable to complete test case: matching error for %s" % str(e))
			setverdict('fail')

		log("End of testcase reached.")

class TC_TEMPLATE_MATCH_LIST(TestCase):
	def body(self):
		log("Testerman autotest: template matching, list")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		def assert_match(message, template):
			res = StateManager(False)
			t = Timer(1.0)
			t.start()
			p01.send(message)
			alt([
				[ p02.RECEIVE(template),
					lambda: res.set(True)
				],
				[ p02.RECEIVE(),
				],
				[ t.TIMEOUT,
				],
			])
			t.stop()
			return res.get()
			
		try:
			# Unit testing: simple types
			if not assert_match([], None): raise Exception('(none/0)')
			if not assert_match([], any_or_none()): raise Exception('(any_or_none/0)')
			# we should have a mismatch here: any() requires at least one element in list
			if assert_match([], any()): raise Exception('(any/0)')
			if not assert_match([1], None): raise Exception('(none/1)')
			if not assert_match([1], any_or_none()): raise Exception('(any_or_none/1)')
			if not assert_match([1], any()): raise Exception('(any/1)')

			if not assert_match([1, 2], [1, 2]): raise Exception('(ordered/1)')
			# order matters
			if assert_match([1, 2], [2, 1]): raise Exception('(ordered/2)')
			# wildcards
			if not assert_match([1, 2, 3], [1, any(), 3]): raise Exception('(wildcard/1)')
			if not assert_match([1, 2, 3], [1, any_or_none(), 3]): raise Exception('(wildcard/2)')
			# still verifying order
			if assert_match([1, 2, 3], [3, any(), 2]): raise Exception('(wildcard/3)')
			# wildcards *
			if not assert_match([1, 2, 3], [any_or_none(), 3]): raise Exception('(wildcard/4)')
			if assert_match([1, 2, 3], [any(), 3]): raise Exception('(wildcard/5)')
			if not assert_match([1, 2, 3], [1, 2, any_or_none()]): raise Exception('(wildcard/6)')
			if not assert_match([1, 2, 3], [any_or_none()]): raise Exception('(wildcard/7)')
			if not assert_match([1, 2, 3, 4], [1, any_or_none(), 4]): raise Exception('(wildcard/8)')
			if not assert_match([1, 3], [1, any_or_none(), 3]): raise Exception('(wildcard/10)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, any(), 6, 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, 5, 6, any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), 5, any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), 1, any_or_none()]): raise Exception('(wildcard/9)')
			if assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 1, any_or_none()]): raise Exception('(wildcard/9)')

			setverdict('pass')
		except Exception, e:
			log("Unable to complete test case: matching error for %s" % str(e))
			setverdict('fail')

class TC_TEMPLATE_WILDCARDS_CONTAINS(TestCase):
	def body(self):
		log("Testerman autotest: contains() wildcard, including nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'name': 'element1', 'value': 123 }
		element2 = { 'name': 'element2', 'value': 434 }
		element3 = { 'name': 'element3', 'value': 123 }
		element4 = { 'name': 'element3', 'value': 1000 }

		# Basic matching
		p01.send([ element1, element2, element3 ])
		alt([
			[ p02.RECEIVE(contains( element3 )),
				lambda: log("basic matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Basic mistmatching
		p01.send([ element1, element2, element3 ])
		alt([
			[ p02.RECEIVE(contains( element4 )),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("basic mismatching OK"),
			],
		])

		# Netsted conditions, matching
		p01.send([ element1, element2, element3, element4 ])
		alt([
			[ p02.RECEIVE(contains( { 'value': greater_than(500) } )),
				lambda: log("nested conditions matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Neted conditions, mismatching
		p01.send([ element1, element2, element3, element4 ])
		alt([
			[ p02.RECEIVE(contains( { 'value': greater_than(1500) } )),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("nested conditions mismatching OK"),
			],
		])

		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_LENGTH(TestCase):
	"""
	Typical length() usages, i.e. including sub-scalar conditions.
	"""
	def body(self):
		log("Testerman autotest: length() wildcard, including nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Length Equality: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(4)),
				lambda: log("basic matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length Equality: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(3)),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("basic mismatching OK"),
			],
		])

		# Length greater than: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(greater_than(3))),
				lambda: log("greater than matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length greater than: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(greater_than(5))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("greater than mismatching OK"),
			],
		])

		# Length lower than: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(lower_than(10))),
				lambda: log("lower than matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length lower than: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(lower_than(3))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("lower than mismatching OK"),
			],
		])

		# Length between: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(between(3, 6))),
				lambda: log("between matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length between: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(between(1, 3))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("between mismatching OK"),
			],
		])
		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_NOT(TestCase):
	"""
	Several not_() usages.
	"""
	def body(self):
		log("Testerman autotest: not_() wildcard, with nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Basic not matching
		p01.send(10)
		alt([
			[ p02.RECEIVE(not_(9)),
				lambda: log("not matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])
		
		# Basic not mistmatching
		p01.send(10)
		alt([
			[ p02.RECEIVE(not_(10)),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("not mismatching OK"),
			],
		])

		# length negation: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(not_(length(between(1, 3)))),
				lambda: log("between matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# length negation: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(not_(length(between(1, 10)))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("between mismatching OK"),
			],
		])

		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_OMIT(TestCase):
	"""
	Basic omit() verification
	"""
	def body(self):
		log("Testerman autotest: omit() wildcard")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Basic not matching
		p01.send({ 'f1': 'value1', 'f2': 'value2' })
		alt([
			[ p02.RECEIVE({ 'f1': 'value1', 'f3': omit() }),
				lambda: log("omit matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])
		
		# Basic not mistmatching
		p01.send({ 'f1': 'value1', 'f2': 'value2' })
		alt([
			[ p02.RECEIVE({ 'f1': 'value1', 'f2': omit() }),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("omit mismatching OK"),
			],
		])
		setverdict('pass')

class TC_UNICODE(TestCase):
	"""
	Verifies that we can send unicode strings (and log them correctly).
	"""
	def body(self):
		log("Starting unicode support in ATS...")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'name': u'élément', 'value': 123 }

		log(u"User log: sending élément")

		p01.send(element1)
		alt([
			[ p02.RECEIVE(element1),
			],
			[ p02.RECEIVE(None),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class TC_UNICODE_SESSION_PARAMETERS(TestCase):
	"""
	Verifies that the user can set unicode parameters in session parameters.
	"""
	def body(self):
		log("Starting unicode support from Session...")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		log("User log: sending %s" % get_variable('PX_UNICODE_STRING'))
		
		element1 = { 'name': get_variable('PX_UNICODE_STRING') }

		# Complete matching
		p01.send(element1)
		alt([
			[ p02.RECEIVE({ 'name': u'ça marche' }),
			],
			[ p02.RECEIVE(None),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class TC_BINARY_LOGGING(TestCase):
	"""
	Verifies that we can send binary payload - should
	not lead to an exception when generating associated logs.
	"""
	def body(self):
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'binary-value': '\x12\xff\x00' }
		
		log("Sending some binarany data: %s" % element1)

		p01.send(element1)
		alt([
			[ p02.RECEIVE({ 'binary-value': octetstring('12ff00')}),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class BEHAVIOUR_LOOP(Behaviour):
	"""
	A looping behaviour, used to test stop(), kill() ptc methods.
	"""
	def body(self):
		control = self['control']
		alt([
			[ control.RECEIVE(),
				lambda: log('Received an event on control port. Gracefully stopping...')
			]
		])
		setverdict('pass')

class TC_STOP_PTC_DONE_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a DONE event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		control.send("It's time to stop")
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.DONE,
				lambda: log("PTC gracefully stopped, signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not stopped as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		# Verdict from PTC
		
class TC_STOP_PTC_DONE(TestCase):
	"""
	Verifies that a ptc.done() operation works correctly.
	Blocks if not...
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		control.send("It's time to stop")
		ptc.done()
		# Verdict from PTC

class TC_STOP_PTC_STOP(TestCase):
	"""
	Verifies that a running PTC with an infinite alt can be stopped from outside (explicit ptc.stop())
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
	
		ptc.stop()
		
		ptc.done()
		# Normally we get the Verdict from PTC - the last known verdict,
		# which is probably none when stopping a PTC from outside (but not necessarely)
		setverdict('pass')

class TC_STOP_PTC_STOP_TESTCASE(TestCase):
	"""
	Verifies that a running PTC with an infinite alt can be stopped when stopping the testcase (implicit stop)
	
	Note that this testcase is either pass, or never returns. So no "fail" is possible for it.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())

		setverdict('pass')
		# We don't wait for the ptc completion. We stop the testcase.
		stop()

class TC_KILL_PTC_KILLED_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a KILLED event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		ptc.kill()
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.KILLED,
				lambda: log("PTC killed, signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not stopped as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')

class TC_KILL_PTC_DONE_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a DONE event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		ptc.kill()
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.DONE,
				lambda: log("PTC killed, done signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not killed as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')

class TC_KILL_PTC_DONE(TestCase):
	"""
	Verifies that a ptc.done() operation works correctly after a kill() op.
	This test is actually useless: TC_KILL_PTC_DONE_EVENT tests it, too.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())

		ptc.kill()
		ptc.done()
		setverdict('pass')

class TC_ACTION(TestCase):
	"""
	Verifies that calling action() with timeout works.
	"""
	def body(self):
		t = Timer(7.0)
		t.start()
		action("If you see me, click me", timeout = 5.0)
		duration = t.read()
		t.stop()
		delta = 0.200 # 200ms of tolerance
		if duration > (5.0 + delta):
			log("Too long to perform action (implictly or not)")
			self.setverdict('fail')
		else:
			self.setverdict('pass')
	


##
# Control definition
##

enable_debug_logs()

TC_TIMER("Testerman autotest: timer management").execute()
TC_SIMPLE_CONNECTION("Testerman autotest: basic").execute()
TC_SIMPLE_1TON("Testerman autotest: 1 to N connections").execute()
TC_SIMPLE_1TON_SUBSET("Testerman autotest: 1 to N connections, sending to selected components").execute()
TC_SIMPLE_PTC("Testerman autotest: PTC behavior").execute()
TC_ALIVE_AND_NONALIVE("Testerman autotest: alive vs non-alive test component").execute()
TC_VALUE_EXTRACTION("Testerman autotest: template matching with extraction").execute()
TC_CODEC("Testerman autotest: simple codec management in templates").execute()

TC_TEMPLATE_MATCH_GENERAL("Testerman autotest: template matching").execute()
TC_TEMPLATE_MATCH_LIST("Testerman autotest: list matching").execute()
TC_TEMPLATE_WILDCARDS_CONTAINS("Testerman autotest: contains() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_LENGTH("Testerman autotest: length() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_NOT("Testerman autotest: not_() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_OMIT("Testerman autotest: omit() matchin mechanism").execute()

TC_UNICODE("Testerman autotest: unicode support in messages (+ logs)").execute()
TC_UNICODE_SESSION_PARAMETERS("Testerman autotest: unicode support in session parameters").execute()
TC_BINARY_LOGGING("Testerman autotest: binary support in messages (+ logs)").execute()

TC_STOP_PTC_DONE_EVENT().execute()
TC_STOP_PTC_DONE().execute()
TC_STOP_PTC_STOP().execute()
TC_STOP_PTC_STOP_TESTCASE().execute()
TC_KILL_PTC_DONE_EVENT().execute()
TC_KILL_PTC_KILLED_EVENT().execute()
TC_KILL_PTC_DONE().execute()
TC_ACTION().execute()
