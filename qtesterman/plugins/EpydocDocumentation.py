# -*- coding: utf-8 -*-
##
# This file is part of Testerman, a test automation system.
# Copyright (c) 2009 QTesterman contributors
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
##

##
# A documentation generator plugin that
# extract a module/ATS documentation using epydoc.
#
##

from PyQt4.Qt import *

import Documentation
import DocumentModels
import Plugin
import PluginManager

import base64
import compiler
import gc
import os

# Plugin ID, as generated by uuidgen / uuid.uuid1()
PLUGIN_ID = '5fe462e1-25cd-11de-8dbb-00037abe8aae'
PLUGIN_LABEL = "Epydoc documentation"
PLUGIN_DESCRIPTION = "A wrapper over Epydoc to create module/ats documentation."
PLUGIN_VERSION = "1.0.0"


##############################################################################
# Documentation manager
##############################################################################

from PyQt4.Qt import *

import os
import os.path
import tempfile
import sys
import tempfile

try:
	# Python 2.5+ preferred hash lib
	import hashlib as md5
except:
	import md5


def log(txt):
	print txt


CACHE_INDEX_FILENAME = "cache.index"

class DocumentationCacheManager(QObject):
	"""
	Manage a cache containing documentations for documentable files (i.e. mainly modules).

	The cache is identified by a cacheRoot directory.

	The cache is a persistent directory (the cache root) (typically in the user home dir)
	containing:
	- cache.index:
		a utf-8 encoded file containing lines:
		key;digest;path
		where:
		- key is a key identifying the resource whose doc is cached (typically a module ID)
		- digest is a md5/sha sum corresponding to the resource, enabling to know if we should
			regenerate the cache or not
		- path is the path relative to the cache root that contains the doc entry point (index.html)
	- one directory per resource, containing its associated docs. The directory name is
		unique and 'random'.
	"""
	def __init__(self, cacheRoot, parent = None):
		"""
		Initialize a cache manager using cacheRoot as cache root directory.
		The cache is initialized upon creation (dir and cache index created).
		So you may get an exception in case of incorrect writing rights.

		@type  cacheRoot: unicode string
		@param cacheRoot: the cache root directory
		"""
		QObject.__init__(self, parent)

		self.cacheRoot = cacheRoot
		self.cacheIndexFilename = self.cacheRoot + '/' + CACHE_INDEX_FILENAME
		
		# Initial directory and index creation
		if not os.path.isdir(self.cacheRoot):
			# May raise some exception if we can't create the dir. Let's the caller get them
			os.makedirs(self.cacheRoot)
		if not os.path.isfile(self.cacheIndexFilename):
			self.saveCacheIndex({})

	def generateDocumentation(self, content, key, force = False):
		"""
		Conditionally generates the doc for the given content.
		If force is True, always regenerates it. Otherwise generate it only if
		the content for this key has been updated or the doc has never been generated.

		@type  content: unicode string
		@param content:
		@type  key: unicode string
		@param key: the key enabling to retrieve the doc later from the cache
		@type  force: boolean
		@param force: if True, force regeneration, regardless of the current cache status

		@rtype: unicode string, or None
		@returns: the complete path to the generated documentation entry point in the cache,
		or None in case of an error.
		"""
		digest = self.getDigest(content)
		e = self.getCacheEntry(key)

		# Cache hit ?
		if not force:
			if e and e[1] == digest:
				log("Documentation cache hit.")
				return os.path.normpath(self.cacheRoot + '/' + e[2] + '/index.html')

		# In all other cases, we have to regenerate the doc.
		# If the entry exists in the case, we reuse its directory
		if e:
			outputDir = self.cacheRoot + '/' + e[2]
		else:
			outputDir = tempfile.mkdtemp(dir = self.cacheRoot)

		(fd, inputFilename) = tempfile.mkstemp()
		f = os.fdopen(fd, 'w')
		f.write(content.encode('utf-8'))
		f.close()

		if self.epydocDocumentation(unicode(key.split('/')[-1]), inputFilename, os.path.normpath(outputDir)):
			os.remove(inputFilename)
			docPath = outputDir[len(self.cacheRoot + '/'):]
			# Finally let's update our cache index.
			self.updateCacheEntry(key, digest, docPath)

			return os.path.normpath(outputDir + '/index.html')

		os.remove(inputFilename)
		return None

	def epydocDocumentation(self, name, inputFilename, outputDir):
		"""
		Calls epydoc to generate (HTML) documentation for filename inputFilename to outputDir.

		@type  name: unicode string
		@param name: the name of the item to document
		@type  inputFilename: unicode string
		@param inputFilename: a path to the file (typically a module) to document with epydoc
		@type  outputDir: unicode string
		@param outputDir: the output directory. Will be created if it does not exist.
		
		@rtype: boolean
		@returns: True if OK, False otherwise
		"""
		cmd = sys.executable
		args = [ '-m', 'epydoc.cli', '--html', 
						 '--fail-on-error', '--parse-only',
						 '--no-frames', # Not supported by QTextBrowser (< Qt 4.4); will be OK for Qt 4.4/WebKit
						 '-n', name,
						 '-o', outputDir, inputFilename ]
		process = QProcess(self)
		process.setProcessChannelMode(QProcess.MergedChannels)
		env = QProcess.systemEnvironment()
		env.append("PYTHONPATH=%s" % QApplication.instance().get('qtestermanpath'))
		process.setEnvironment(env)
		log("Starting documentation generation: " + unicode(args))
		process.start(cmd, args)
		if not process.waitForFinished():
			log("ERROR: unable to finish on time: epydoc output: " + unicode(process.readAll()))
			return False
		else:
			if process.exitCode():
				log("ERROR: epydoc output: " + unicode(process.readAll()))
				return False
			else:
				log("FYI: epydoc output: " + unicode(process.readAll()))
				return True

	def getDigest(self, content):
		"""
		Generates a digest/signature for a content.
		In this implementation, this returns a md5 hash.

		@type  content: unicode string
		@param content: the content to digest

		@rtype: string
		@returns: an ascii string representing the digest.
		"""
		return md5.md5(content.encode('utf-8')).hexdigest()

	def loadCacheIndex(self):
		"""
		Loads the cache index as a dict[key] = (key, digest, docPath)

		@rtype: dict[unicode] of (unicode, string, unicode)
		@returns: the cache index, empty dict is possible or in case of a read error.
		"""
		res = {}
		f = open(self.cacheIndexFilename, 'r')
		lines = f.readlines()
		f.close()
		for line in lines:
			try:
				(key, digest, docPath) = line.strip().split(';')
			except Exception:
				# invalid line, ignore it
				log("Invalid line in cache index (%s), ignoring" % line)
			k = key.decode('utf-8')
			res[k] = ((k, digest, docPath.decode('utf-8')))
		return res

	def getCacheEntry(self, key):
		"""
		Gets the complete cache entry for a key.

		@type  key: unicode string
		@param key: unicode string
		@rtype: tuple (unicode string, string, unicode string) or None
		@returns: a tuple (key, digest, docPath) if the key was found, None otherwise
		"""
		index = self.loadCacheIndex()
		if index.has_key(key):
			return index[key]
		return None

	def updateCacheEntry(self, key, digest, docPath):
		"""
		Updates the cache index with a key;digest;docPath entry.

		@type  docPath: unicode string or string
		@type  key: unicode string or string
		@type  digest: string
		"""
		key = unicode(key).encode('utf-8')
		docPath = unicode(docPath).encode('utf-8')

		index = self.loadCacheIndex()
		index[key] = (key, digest, docPath)
		self.saveCacheIndex(index)

	def saveCacheIndex(self, index):
		"""
		Save the cache index to the persistent storage.

		@type  index: dict[unicode] of (unicode, string, unicode)
		@param index: the cache index, as built by loadCacheIndex()
		"""
		f = open(self.cacheIndexFilename, 'w')
		for key, (_, digest, docPath) in index.items():
			f.write('%s;%s;%s\n' % (key.encode('utf-8'), digest, docPath.encode('utf-8')))
		f.close()

##############################################################################
# View
##############################################################################

class WDocumentationView(QWidget):
	"""
	This widget displays a documentation through a HTML viewer.
	Basic search function.
	"""
	def __init__(self, pathToIndex, title, parent = None):
		QWidget.__init__(self, parent)
		self.__createWidgets()
		self.setWindowTitle(title)
		log("Setting documentation source to: %s" % pathToIndex)
		self.browser.setSource(QUrl.fromLocalFile(pathToIndex))

	def __createWidgets(self):
		layout = QVBoxLayout()

		self.browser = QTextBrowser()
		self.browser.setOpenExternalLinks(True)
		layout.addWidget(self.browser)

		self.buttonLayout = QHBoxLayout()
		self.buttonLayout.addWidget(CommonWidgets.WFind(self.browser))
		layout.addLayout(self.buttonLayout)

		self.setLayout(layout)


##############################################################################
# Plugin
##############################################################################

import CommonWidgets

class WPlugin(Plugin.DocumentationGenerator):
	def __init__(self, parent = None):
		Plugin.DocumentationGenerator.__init__(self, parent)

	def activate(self, model):
		self._showContentDocumentation(content = unicode(model.getBodyModel()), key = model.getUrl().toString())

	def isDocumentTypeSupported(self, documentType):
		return documentType in [ DocumentModels.TYPE_ATS, DocumentModels.TYPE_MODULE ]

	def _showContentDocumentation(self, content, key):
		settings = QSettings()
		path = "plugins/%s" % PLUGIN_ID
		defaultDocumentationCache = os.path.normpath(unicode(QDir.homePath()) + "/.testerman/")
		documentationCache = os.path.normpath(unicode(settings.value('%s/cacheDir' % path, QVariant(QString(defaultDocumentationCache))).toString()) + "/docCache")
		cache = DocumentationCacheManager(documentationCache)
		transient = CommonWidgets.WTransientWindow("Doc Generator", self.parent())
		transient.showTextLabel("Generating documentation...")
		path = cache.generateDocumentation(content, key)
		transient.hide()
		transient.setParent(None)
		if path:
			view = WDocumentationView(path, "Documentation for %s" % key, self.parent())
			view.setWindowFlags(Qt.Window)
			view.resize(QSize(800, 600))
			view.show()
		else:
			CommonWidgets.systemError(parent, "Unable to generate documentation, please check stderr output.\nPlease check epydoc syntax and indentation")


###############################################################################
# Plugin Configuration Dialog
###############################################################################

class WPluginConfiguration(Plugin.WPluginConfiguration):
	def __init__(self, parent = None):
		Plugin.WPluginConfiguration.__init__(self, parent)
		self.__createWidgets()

	def __createWidgets(self):
		vlayout = QVBoxLayout()
		layout = QGridLayout()
		# Documentation cache location + browse directory button
		layout.addWidget(QLabel("Documentation cache:"), 0, 0, 1, 2)
		self.documentationCacheLineEdit = QLineEdit()
		self.browseDirectoryButton = QPushButton("...")
		self.connect(self.browseDirectoryButton, SIGNAL('clicked()'), self._browseForCacheDirectory)
		layout.addWidget(self.documentationCacheLineEdit, 1, 0)
		layout.addWidget(self.browseDirectoryButton, 1, 1)
		# Documentation cache clean button
		self.cleanDocumentationCacheButton = QPushButton("Clean cache now")
		self.connect(self.cleanDocumentationCacheButton, SIGNAL('clicked()'), self._cleanDocumentationCache)
		layout.addWidget(self.cleanDocumentationCacheButton, 2, 0, 1, 2)
		vlayout.addLayout(layout)
		vlayout.addStretch()
		self.setLayout(vlayout)

	def _browseForCacheDirectory(self):
		documentationCache = QFileDialog.getExistingDirectory(self, "Documentation cache root directory", self.documentationCacheLineEdit.text())
		if not documentationCache.isEmpty():
			self.documentationCacheLineEdit.setText(os.path.normpath(unicode(documentationCache)))

	def _cleanDocumentationCache(self):
		# The cache is actually a subdir "docCache" within the configuration dir.
		# This keeps the user from selecting an existing directory that contains other things than the pure cache data,
		# and click "clean". For instance, it would be trivial to delete a complete Program Files (or windows...) directory without this 
		# additional suffix.
		documentationCache = os.path.normpath(unicode(self.documentationCacheLineEdit.text()) + "/docCache")
		print "DEBUG: cleaning " + unicode(documentationCache) + "..."
		shutil.rmtree(documentationCache, ignore_errors = True)
		userInformation(self, "Documentation cache directory cleaned up.")

	def displayConfiguration(self):
		settings = QSettings()
		path = "plugins/%s" % PLUGIN_ID
		# Default documentation cache root
		defaultDocumentationCache = os.path.normpath(unicode(QDir.homePath()) + "/.testerman/")
		documentationCache = settings.value('%s/cacheDir' % path, QVariant(QString(defaultDocumentationCache))).toString()
		self.documentationCacheLineEdit.setText(documentationCache)

	def checkConfiguration(self):
		"""
		Check the data model, return 1 if OK, 0 if not.
		"""
		return True

	def saveConfiguration(self):
		"""
		Update the data model.
		"""
		settings = QSettings()
		path = "plugins/%s" % PLUGIN_ID

		documentationCache = self.documentationCacheLineEdit.text()
		# We save them as settings
		settings = QSettings()
		settings.setValue('%s/cacheDir' % path, QVariant(documentationCache))


PluginManager.registerPluginClass(PLUGIN_LABEL, PLUGIN_ID, WPlugin, WPluginConfiguration, description = PLUGIN_DESCRIPTION, version = PLUGIN_VERSION)

